# Vulkan Fundamentals

本章介绍基本概念，包括Vulkan体系结构和执行模型，API语法，队列，管线配置，数值表示，状态和状态查询以及不同类型的对象和着色器。 它提供了一个框架，用于解释规范其余部分中对命令和行为的更具体描述。

## 主机(Host)和设备(Device)环境

Vulkan规范假设并要求：与Vulkan实现相关的主机环境的以下属性：

- 主机必须具有8,16,32和64位有符号和无符号二进制补码整数的运行时支持，所有这些都可以以其大小（以字节为单位）的粒度进行寻址。

- 主机必须具有32位和64位浮点类型的运行时支持，以满足浮点计算部分中的范围和精度约束。

- 主机上这些类型的表示和字节顺序必须与所支持的每个物理设备上相同类型的表示和字节顺序相匹配。

> **注意** 由于主机和物理设备操作都可以访问Vulkan中的各种数据类型和结构，因此实现应该能够在两个途径中有效地访问这些数据，以便于编写可移植和高性能的应用程序。

## 执行模型

本节概述了Vulkan系统的执行模型。

Vulkan暴露一个或多个设备，每个设备暴露一个或多个队列，这些队列可以彼此异步地处理工作。 设备支持的队列集分为多个族。 每个系列都支持一种或多种类型的功能，并且可能包含具有类似特征的多个队列。 单个系列中的队列被认为是彼此兼容的，并且可以在该系列中的任何队列上执行为一系列队列生成的工作。 本规范定义了队列可能支持的四种类型的功能：图形，计算，传输和稀疏内存管理。

>  [**注意** 单个设备可能会暴露多个类似的队列系列，而不是报告这些系列中的一个或多个系列的多个成员。 这表明虽然这些队列族的成员具有相似的能力，但他们并不直接相互兼容。]()

设备内存由应用程序显式管理。 [每个设备可以通告一个或多个堆]()，代表不同的存储区域。 内存堆可以是device local或host local，但始终对设备可见。 关于内存堆的更多细节通过该堆上可用的内存类型公开。 可以在实现上使用的存储区的示例包括：

- device local，是物理连接到设备的内存。

- device local，host visible 是主机可见的设备本地内存。

- host local，host visible 是主机本地的内存，对设备和主机可见。

在其他体系结构上，可能只有一个堆可用于任何目的。

Vulkan应用程序通过提交命令缓冲来控制一组设备，这些命令缓冲记录了通过Vulkan库调用发出的设备命令。 命令缓冲的内容特定于底层实现，对应用程序不透明。 构造完成后，可以将命令缓冲一次或多次提交给队列执行。 通过在应用程序中使用多个线程，可以并行构建多个命令缓冲区。

提交给不同队列的命令缓冲可以相互并行地执行，甚至可以不按顺序执行。 提交到单个队列的命令缓冲区遵循提交顺序，如同步章节中进一步描述的那样。 设备执行的命令缓冲区对于主机执行也是异步的。 将命令缓冲区提交到队列后，控件可立即返回应用程序。 设备和主机之间以及不同队列之间的同步是应用程序的责任。

### 队列操作

Vulkan队列为设备的执行引擎提供接口。 这些执行引擎的命令在执行时间之前被记录到命令缓冲中。 然后使用队列提交命令将这些命令缓冲提交给队列，以便在多个批次中执行。 一旦提交到队列，这些命令将开始并完成执行而无需进一步的应用程序干预，但此执行的顺序取决于许多隐式和显式排序约束。

使用队列提交命令将工作提交给队列，该命令通常采用vkQueue\*形式（例如vkQueueSubmit，vkQueueBindSparse），并且可选择在任务开始之前获取等待信号的信号量列表以及在任务完成后获取释放信号的信号量列表。 执行的任务本身，以及释放信号量和等待信号量都是队列操作。

不同队列上的队列操作没有隐式排序约束，并且可以按任何顺序执行。 队列之间的显式排序约束可以用信号量和栅栏表示。

提交到单个队列的命令缓冲区中的命令遵循提交顺序和其他隐式排序保证，否则可能重叠或无序执行。 [针对单个队列的其他类型的批处理和队列提交（例如，稀疏存储器绑定）对于任何其他队列提交或批处理没有隐式排序约束。 队列提交和单个批次之间的其他显式排序约束可以用信号量和栅栏表示。]()

在栅栏或信号量信号被释放之前，可以保证任何先前提交的队列操作已完成执行，并且来自这些队列操作的存储器写入可用于将来的队列操作。 等待发信号的信号量或栅栏保证可用的先前写入对后续命令也是可见的。

[在相同或不同批次或提交的主命令缓冲区之间以及主命令缓冲区和辅助命令缓冲区之间的命令缓冲区边界不会引入任何其他排序约束。]() 换句话说，在任何信号量或围栏操作之间提交命令缓冲区集（可以包括执行辅助命令缓冲区）执行记录的命令，就好像它们都被记录到单个主命令缓冲区中一样，除了当前状态被重置 在每个边界上。 可以使用显式同步原语来表达显式排序约束。

命令缓冲区中的命令之间存在一些隐式排序保证，但仅涵盖执行的子集。 可以使用各种显式同步原语来表达附加的显式排序约束。

> **注意** 实现具有很大的自由来重叠提交到队列的工作的执行，这是常见的，因为Vulkan设备中的深度的流水线和并行性特性。

记录在命令缓冲中的命令执行操作（绘制，分派，清除，复制，查询/时间戳操作，开始/结束subpass操作），设置状态（绑定管道，描述符集和缓冲区，设置动态状态，推送常量，设置渲染） 传递/子传递状态），或执行同步（设置/等待事件，管道屏障，渲染传递/子传递依赖关系）。 某些命令执行多个这些任务。 状态设置命令更新命令缓冲区的当前状态。 执行动作的一些命令（例如绘制/分派）基于自命令缓冲区启动以来累积的当前状态集来执行此操作。 执行操作命令所涉及的工作通常允许重叠或重新排序，但这样做不得改变每个操作命令要使用的状态。 通常，操作命令是那些改变帧缓冲附件，读/写缓冲区或图像内存或写入查询池的命令。

同步命令在两组动作命令之间引入显式执行和内存依赖性，其中第二组命令取决于第一组命令。 这些依赖性强制后面集合中的某些流水线阶段的执行在前面集合中的某些阶段的执行之后发生，并且由某些流水线阶段执行的存储器访问的效果按顺序发生并且彼此可见。 如果未通过显式依赖或隐式排序保证强制执行，则操作命令可能会重叠执行或无序执行，并且可能无法看到彼此的内存访问的副作用。

设备相对于主机异步执行队列操作。 在命令缓冲区提交到队列之后，控制立即返回到应用程序。 应用程序必须根据需要在主机和设备之间同步工作。

## 对象模型

Vulkan中的设备，队列和其他实体由Vulkan对象表示。 在API级别，所有对象都由句柄引用。 有两类句柄，可分派和不可分派。 可分派句柄类型是指向不透明类型的指针。 [层可以使用该指针作为拦截API命令的一部分，因此每个API命令都采用可调度类型作为其第一个参数。]() 可分派类型的每个对象在其生命周期内必须具有唯一的句柄值。

不可分派的句柄类型是64位整数类型，其含义与实现有关，并且可以直接在句柄中编码对象信息，而不是作为对底层对象的引用。 不可分派类型的对象在类型内或跨类型可能没有唯一的句柄值。 如果句柄值不是唯一的，那么销毁一个这样的句柄不能导致其他类型的相同句柄变得无效，并且如果该句柄值的创建次数比销毁次数多，不能导致相同类型的相同句柄变为无效。 

从VkDevice创建或分配的所有对象（即使用VkDevice作为第一个参数）对该设备是私有的，不得在其他设备上使用。

### 对象生存期

对象分别由vkCreate\*和vkAllocate\*命令创建或分配。 一旦创建或分配了一个对象，它的“结构”就被认为是不可变的，尽管某些对象类型的内容仍然可以自由改变。 vkDestroy\*和vkFree\*命令分别销毁或释放对象。

分配（而不是创建）的对象从现有对象池或内存堆中获取资源，并在释放时将资源返回到该池或堆。 虽然通常期望对象创建和销毁是在运行时期间发生的低频事件，但是分配和释放对象可以以高频率发生。 对象池有助于提高分配和释放的性能。

应用程序负责跟踪Vulkan对象的生命周期，而不是在它们仍在使用时销毁它们。

应用程序拥有的内存的所有权立即被传入的任何Vulkan命令获取。 必须在命令持续时间结束时将此类内存的所有权释放回应用程序，以便应用程序可以在获取它的所有命令都返回后立即更改或释放此内存。

传递给Vulkan命令时，将消耗以下对象类型，而这些对象类型不会被用于创建的对象进一步访问。 在传递给它们的任何API命令的持续时间内，不得销毁它们：

- `VkShaderModule`
- `VkPipelineCache`
- `VkValidationCacheEXT`

在传递命令的持续时间之后，该对象不会进一步访问作为参数传递的VkRenderPass对象以创建另一个对象。 命令缓冲区中使用的VkRenderPass遵循下面描述的规则。

当使用它的任何命令缓冲区处于记录状态时，不得销毁VkPipelineLayout对象。

可以通过对使用该布局分配的描述符集进行操作的命令来访问VkDescriptorSetLayout对象，并且在VkDescriptorSetLayout被销毁之后，不得使用vkUpdateDescriptorSets更新那些描述符集。 否则，在传递命令的持续时间之后，该对象不会进一步访问作为参数传递的VkDescriptorSetLayout对象以创建另一个对象。

在设备对该对象的所有使用（例如通过命令缓冲区执行）完成之前，应用程序不得销毁任何其他类型的Vulkan对象。

当使用该对象的任何命令缓冲区处于挂起状态时，不得销毁以下Vulkan对象：

- `VkEvent`
- `VkQueryPool`
- `VkBuffer`
- `VkBufferView`
- `VkImage`
- `VkImageView`
- `VkPipeline`
- `VkSampler`
- [VkSamplerYcbcrConversion](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerYcbcrConversion)
- `VkDescriptorPool`
- `VkFramebuffer`
- `VkRenderPass`
- `VkCommandBuffer`
- `VkCommandPool`
- `VkDeviceMemory`
- `VkDescriptorSet`
- `VkObjectTableNVX`
- `VkIndirectCommandsLayoutNVX`

销毁这些对象会将处于记录或可执行状态且正在使用这些对象的任何命令缓冲区变为无效状态。

在任何队列执行使用该对象的命令时，不得销毁以下Vulkan对象：

- 无法显式销毁VkQueue对象。 相反，当从中检索它们的VkDevice对象被销毁时，它们被隐式销毁。

- 销毁池对象会隐式释放从该池分配的所有对象。 具体来说，销毁VkCommandPool会释放从中分配的所有VkCommandBuffer对象，并且销毁VkDescriptorPool会释放从中分配的所有VkDescriptorSet对象。

- 当从它们检索的所有VkQueue对象都空闲时，可以销毁VkDevice对象，并且已经销毁了从它们创建的所有对象。 这包括以下对象：
  - `VkFence`
  - `VkSemaphore`
  - `VkCommandBuffer`
  - `VkCommandPool`

通常，对象可以按任何顺序销毁或释放，即使被释放的对象涉及另一个对象的使用（例如，在视图中使用资源，在描述符集中使用视图，使用对象） 在命令缓冲区中，将内存分配绑定到资源上），只要使用释放对象的任何对象不以任何方式进一步使用，除非被销毁或以不再使用的方式重置 其他对象（例如重置命令缓冲区）。 如果对象已被重置，则可以使用它，就好像它从未使用过释放的对象一样。 例外情况是对象之间存在父/子关系。 在这种情况下，应用程序不得在其子节点之前销毁父对象，除非明确定义父节点以在子节点被销毁时释放其子节点（例如，对于池对象，如下所述）。

VkCommandPool对象是VkCommandBuffer对象的父对象。 VkDescriptorPool对象是VkDescriptorSet对象的父对象。 VkDevice对象是许多对象类型的父对象（所有这些对象都将VkDevice作为其创建的参数）。

以下Vulkan对象对何时可以销毁具有特定限制：

  - kFence`
  - `VkSemaphore`
  - `VkEvent`
  - `VkQueryPool`
  - `VkBuffer`
  - `VkBufferView`
  - `VkImage`
  - `VkImageView`
  - `VkShaderModule`
  - `VkPipelineCache`
  - `VkPipeline`
  - `VkPipelineLayout`
  - `VkSampler`
  - [VkSamplerYcbcrConversion](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#VkSamplerYcbcrConversion)
  - `VkDescriptorSetLayout`
  - `VkDescriptorPool`
  - `VkFramebuffer`
  - `VkRenderPass`
  - `VkCommandPool`
  - `VkCommandBuffer`
  - `VkDeviceMemory`
  - `VkValidationCacheEXT`

无法显式销毁VkPhysicalDevice对象。 相反，当从中检索它们的VkInstance对象被销毁时，它们被隐式销毁。

一旦从其任何VkPhysicalDevice对象创建的所有VkDevice对象都被销毁，就可以销毁VkInstance对象。

### 外部对象句柄

如上所述，从VkDevice创建或分配的对象句柄的范围仅限于该逻辑设备。 不在范围内的物体被称为外部物体。 要将外部对象放入作用域，必须从源作用域中的对象导出外部句柄并将其导入目标作用域。

> **注意** 外部句柄及其相关资源的范围可能因类型而异，但通常可以跨进程和API边界共享。

## 应用程序二进制接口

Vulkan可供应用程序使用的机制是平台或实现定义。 在许多平台上，本规范中描述的C接口由共享库提供。 由于共享库可以独立于使用它们的应用程序进行更改，因此它们存在特定的兼容性挑战，并且本规范对它们提出了一些要求。

共享库实现必须使用标准C编译器的默认应用程序二进制接口（ABI），或者提供定制的API头，这会导致应用程序代码使用实现的非默认ABI。 此上下文中的ABI表示C数据类型的大小，对齐和布局; 程序调用约定; 以及与C函数对应的共享库符号的命名约定。 自定义平台的调用约定通常通过在vk_platform.h中适当地定义调用约定宏来完成。

在Vulkan作为共享库提供的平台上，以“vk”开头并后跟数字或大写字母的库符号保留供实现使用。 使用Vulkan的应用程序不得提供这些符号的定义。 这允许使用新API版本或扩展的附加符号更新Vulkan共享库，而不会导致与现有应用程序的符号冲突。

共享库实现应该为它们支持的本规范的最高版本中的命令提供库符号，并为与平台相关的Window System Integration扩展提供库符号。 它们还可以为由附加扩展定义的命令提供库符号。

> **注意** 这些要求和建议旨在允许实现者利用针对SDK，ABI，库版本控制机制等的特定于平台的约定，同时仍然最小化在平台之间移植应用程序或库所需的代码更改。 鼓励平台供应商或平台事实上的标准Vulkan共享库的提供者记录共享库提供的符号以及添加新符号时如何对其进行版本化。

应用程序应仅依赖于应用程序所需的最小核心版本中的命令的共享库符号。 vkGetInstanceProcAddr和vkGetDeviceProcAddr应该用于获取超出应用程序最低要求版本的核心版本中的命令的函数指针。

## 命令语法和持续时间

规范将Vulkan命令描述为使用C99语法的函数或过程。 其他语言（如C ++和JavaScript）的语言绑定可能允许更严格的参数传递或面向对象的接口。

Vulkan使用标准C类型作为标量参数的基本类型（例如来自<stdint.h>的类型），下面描述的例外情况或适当的文本中的其他地方：

VkBool32表示布尔值True和False值，因为C没有足够的可移植内置布尔类型：

```cpp
typedef uint32_t VkBool32;
```

VK_TRUE表示布尔值True（整数1）值，VK_FALSE表示布尔值False（整数0）值。

从VkBool32中的Vulkan实现返回的所有值都是VK_TRUE或VK_FALSE。

应用程序不得将除VK_TRUE或VK_FALSE之外的任何其他值传递到需要VkBool32的Vulkan实现中。

VkDeviceSize表示设备内存大小和偏移值：

```cpp
typedef uint64_t VkDeviceSize;
```

VkDeviceAddress表示设备缓冲区地址值：

```cpp
typedef uint64_t VkDeviceAddress;
```

创建Vulkan对象的命令的格式为vkCreate *，并使用创建对象所需参数的Vk * CreateInfo结构。 使用vkDestroy *形式的命令销毁这些Vulkan对象。

创建或销毁Vulkan对象的每个命令的最后一个in-parameter是pAllocator。 可以将pAllocator参数设置为非NULL值，以便将给定对象的分配委托给应用程序提供的回调; 有关更多详细信息，请参阅“内存分配”一章。

分配池对象拥有的Vulkan对象的命令的格式为vkAllocate *，并采用Vk * AllocateInfo结构。 使用vkFree *形式的命令释放这些Vulkan对象。 这些对象不占用分配器; 如果需要主机内存，它们将使用创建父池时指定的分配器。

通过调用vkCmd *形式的API命令将命令记录到命令缓冲区中。 每个这样的命令可以对其可以使用的位置具有不同的限制：在主要和/或辅助命令缓冲器中，在渲染通道内部和/或外部，以及在一个或多个支持的队列类型中。 这些限制与每个此类命令的定义一起记录。

Vulkan命令的持续时间是指调用命令和返回调用者之间的间隔。

## 线程行为

Vulkan旨在在多个主机线程上使用时提供可扩展的性能。 所有命令都支持从多个线程同时调用，但某些参数或参数组件被定义为外部同步。 这意味着调用者必须保证在给定时间不超过一个线程正在使用这样的参数。

更确切地说，Vulkan命令使用简单存储来更新Vulkan对象的状态。 声明为外部同步的参数可以在主机执行命令期间随时更新其内容。 如果两个命令对同一个对象进行操作，并且至少有一个命令声明该对象是外部同步的，则调用者不仅要保证命令不会同时执行，还要保证两个命令由适当的内存分隔障碍（如果需要）。

> **注意** 内存障碍与基于ARM CPU架构的主机特别相关，后者比许多开发人员习惯使用的x86 / x64编程更加有序。 幸运的是，大多数更高级别的同步原语（如pthread库）作为互斥的一部分执行内存屏障，因此通过这些原语静音Vulkan对象将产生预期的效果。

同样，应用程序必须避免任何由Vulkan命令临时获取其所有权的应用程序拥有的内存的潜在数据危险。 虽然应用程序拥有的内存的所有权仍然由命令获取，但实现可以在任何时候读取内存，并且它可以在任何时候写入非const限定的内存。 引用非const限定应用程序拥有的内存的参数未在规范中明确标记为外部同步。

许多对象类型是不可变的，这意味着对象一旦创建就无法更改。 这些类型的对象永远不需要外部同步，除非它们在另一个线程上使用时不得被销毁。 在某些特殊情况下，可变对象参数在内部同步，从而不需要外部同步。 其中一个例子是在vkCreateGraphicsPipelines和vkCreateComputePipelines中使用VkPipelineCache，其中围绕这种重量级命令的外部同步将是不切实际的。 在此示例中，实现必须在内部同步缓存，并且可以围绕命令以更细粒度的互斥体的形式执行此操作。 任何未标记为外部同步的命令参数都不会被命令突变或在内部同步。 另外，与命令的参数（例如命令池和描述符池）相关的某些对象可能受命令影响，并且还必须在外部同步。

## 错误

Vulkan是一个分层API。 最低层是核心Vulkan层，如本规范所定义。 应用程序可以使用核心上方的其他层来进行调试，验证和其他目的。

Vulkan的核心原则之一是构建和提交命令缓冲区应该是高效的。 因此，尽管可以通过使用层来实现更严格的验证，但核心层中的状态的错误检查和验证是最小的。

核心层假设应用程序正在使用API。 除了规范中其他地方记录之外，核心层对使用API的应用程序的行为不正确是未定义的，并且可能包括程序终止。 但是，实现必须确保应用程序的错误使用不会影响操作系统，Vulkan实现或系统中其他Vulkan客户端应用程序的完整性。 特别是，任何内存分配的Vulkan实现都不得违反操作系统对一个进程的内存是否可以对另一个进程可见的任何保证。 除非应用程序使用特定功能或扩展明确指示，否则Vulkan实现不需要提供超出操作系统提供的安全性或完整性保证。

> **注意** 例如，如果操作系统保证在新分配时将其所有内存分配中的数据设置为零，则Vulkan实现必须对其控制的任何分配（例如VkDeviceMemory）提供相同的保证。
>
> 类似地，如果操作系统保证主机分配之后的释放不会导致另一个进程写入的值变得可见，则必须通过Vulkan实现设备内存来保证。

如果支持受保护的内存功能，则实现会在发生无效使用时提供额外的保证，以防止受保护的内存中的值在受保护的操作之外被访问或推断，如受保护的内存访问规则中所述。

验证图层需要验证正确的API使用情况。 应该在启用验证层的情况下开发应用程序，以帮助捕获和消除错误。 验证后，已发布的应用程序默认情况下不应启用验证层。

## 数值表示和计算

实现通常以浮点执行计算，并且必须满足下面“浮点计算”中定义的范围和精度要求。

这些要求仅适用于在着色器执行之外的Vulkan操作中执行的计算，例如纹理图像规范和采样以及每个片段操作。 着色器执行期间的范围和精度要求不同，并由SPIR-V指令的精度和操作部分指定。

在某些情况下，操作的表示和/或精度由Vulkan使用的顶点或纹素数据的指定格式隐式限制。 具体的浮点格式将在本节后面介绍。

### 浮点数计算

大多数浮点计算在SPIR-V着色器模块中执行。 着色器内的计算属性受SPIR-V指令部分的精度和操作定义的约束。

某些浮点计算在着色器外部执行，例如视口和深度范围计算。 对于这些计算，我们不指定如何表示浮点数，或者如何执行对它们的操作的详细信息，而是仅对表示和精度提出最低要求，如本节其余部分所述。

我们只需要数字的浮点部分包含足够的位，并且它们的指数字段足够大，以便浮点运算的单个结果精确到10^5的大约1个部分。所有浮点值的最大可表示幅度必须至少232。

对于任何非无限且非 NaN x，

x×0 = 0×x = 0。

1×x = x×1 = x。

x + 0 = 0 + x = x。

00 = 1。

有时，还会指定进一步的要求。 大多数单精度浮点格式都满足这些要求。

特殊值Inf和-Inf编码的值太大而无法表示; 特殊值NaN编码由非定义算术运算（如0/0）产生的“非数字”值。实现可在其浮点计算中支持Inf和NaN。

### 浮点数格式转换

当将值转换为定义的浮点表示时，落在两个可表示的有限值之间的有限值将四舍五入为一个或另一个。 舍入模式未定义。 其幅度大于任何可表示的有限值的有限值可以舍入到最接近的可表示的有限值或者适当的有符号无穷大。 对于无符号目标格式，任何负值都将转换为零。 正无穷大转换为正无穷大; 负无穷大以有符号格式转换为负无穷大，以无符号格式转换为零; 任何NaN都转化为NaN。

### 一般要求

任何可表示的适当格式的浮点值都是合法的输入，需要浮点数据的Vulkan命令。 未指定为此类命令提供不是浮点数的值的结果，但不得导致Vulkan中断或终止。 例如，向Vulkan命令提供负零（如果适用）或非规范化数字必须产生确定性结果，而提供NaN或Inf会产生未指定的结果。

有些计算需要划分。 在这种情况下（包括由向量归一化执行的隐含除法），除以零会产生未指定的结果，但不得导致Vulkan中断或终止。

**References:**

- *[Vulkan Specification](https://www.khronos.org/registry/vulkan/specs/1.1-extensions/html/vkspec.html#fundamentals)*
