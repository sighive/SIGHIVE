### 走样

| ![anti_aliasing_rasterization](F:\Projects\Relevant\SIGHIVE\Blog\Pictures\anti_aliasing_rasterization.png)![anti_aliasing_rasterization_filled](F:\Projects\Relevant\SIGHIVE\Blog\Pictures\anti_aliasing_rasterization_filled.png) |
| :----------------------------------------------------------: |
|                     图1：光栅化后的走样                      |

光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。在一个屏幕像素的网格中，每个像素的中心包含有一个采样点(Sample Point)，它会被用来决定这个三角形是否遮盖了某个像素。图1中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形所遮盖，所以这些像素处不会生成片段，从而产生走样。

### 抗锯齿与常见抗锯齿类型总结

抗锯齿（Anti-Aliasing，简称AA），也译为边缘柔化、消除混叠、抗图像折叠有损，反走样等。它是一种消除显示器输出的画面中图物边缘出现凹凸锯齿的技术，那些凹凸的锯齿通常因为高分辨率的信号以低分辨率表示或无法准确运算出3D图形坐标定位时所导致的图形走样（aliasing）而产生的，抗锯齿技术能有效地解决这些问题。

抗锯齿的一般策略是对屏幕使用一个采样模式，然后对样本进行加权和，生成像素颜色p

| ![1556417264105](F:\Projects\Relevant\SIGHIVE\Blog\Pictures\1556417264105.png) |
| :----------------------------------------------------------: |
|                      图2：颜色计算公式                       |

其中n是为像素采集的样本数。函数c(i,x,y)是一个样本颜色，wi是一个权重，在[0,1]范围内,权重相加为1。

#### 超采样抗锯齿(Super Sample Anti-aliasing, SSAA)

SSAA是比较早期的抗锯齿方法，比较消耗资源，但简单直接。以更高的分辨率呈现渲染对象，然后根据邻近的几个样本来进行一个像素的颜色计算。例如，假设需要1280×1024像素大小的渲染结果，首先将渲染对象渲染到一个分辨率为2560×2048像素大小的图像中。然后在屏幕上平均每个2×2像素区域，根据4个像素的采样点计算（下采样）出一个像素的颜色，使得图像大小恢复至1280×1024像素。

SSAA的主要优点是简单，这也是在数学上最完美的抗锯齿方法。但这种方法劣势也十分明显，光栅化和着色的计算以及渲染目标（render target）大小负担比原来多出很多倍。

#### 多重采样抗锯齿(Multisample Anti-aliasing, MSAA)

| ![1556417127822](F:\Projects\Relevant\SIGHIVE\Blog\Pictures\1556417127822.png) |
| :----------------------------------------------------------: |
|                   图3：多重采样抗锯齿方案                    |

多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。

MSAA首先来自于OpenGL。实际使用时MSAA通常只对深度缓存（Z-Buffer）和模板缓存(Stencil Buffer)中的数据进行超级采样抗锯齿的处理。可以简单理解为只对可见的多边形的边缘进行抗锯齿处理。

MSAA比SSAA方案更快，因为每计算一个最终像素颜色只运行一次片段着色器。它致力于以更高的速度对片段的像素覆盖进行采样，并共享计算出的结果。

#### 覆盖采样抗锯齿(CSAA)

覆盖采样抗锯齿（Coverage Sampling Anti-Aliasing，简称CSAA）是NVIDIA在G80及其衍生产品首次推向实用化的AA技术，也是目前NVIDIA GeForce 8/9/G200系列独享的AA技术。CSAA就是在MSAA基础上更进一步的节省显存使用量及带宽，简单说CSAA就是将边缘多边形里需要取样的子像素坐标覆盖掉，把原像素坐标强制安置在硬件和驱动程序预先算好的坐标中。这就好比取样标准统一的MSAA，能够最高效率的执行边缘取样，效能提升非常的显著。

#### 高分辨率抗锯齿(HRAA)

高分辨率抗锯齿方法(High Resolution Anti-Aliasing，简称HRAA)，也称Quincunx方法，也出自NVIDIA公司。“Quincunx”意思是5个物体的排列方式，其中4个在正方形角上，第五个在正方形中心，也就是梅花形，很像六边模型上的五点图案模式。此方法中，采样模式是五点梅花状，其中四个样本在像素单元的角上，各占1/8权重，最后一个在中心，占1/2权重。

| ![20190506172641](F:\Projects\Relevant\SIGHIVE\Blog\Pictures\20190506172641.png) |
| :----------------------------------------------------------: |
|                    图4：Quincunx采样模式                     |





#### 可编程过滤抗锯齿(CFAA)

可编程过滤抗锯齿（Custom Filter Anti-Aliasing，简称CFAA）技术起源于AMD-ATI的R600家庭。简单地说CFAA就是扩大取样面积的MSAA，比方说之前的MSAA是严格选取物体边缘像素进行反走样计算的，而CFAA则可以通过驱动和谐灵活地选择对影响锯齿效果较大的像素进行反走样计算，以较少的性能牺牲换取平滑效果。显卡资源占用也比较小。

#### 形态抗锯齿(MLAA)

形态抗锯齿（Morphological Anti-Aliasing，简称MLAA），是Intel率先提出的，然后AMD推出的完全基于CPU处理的抗锯齿解决方案。与MSAA不同， MLAA将跨越边缘像素的前景和背景色进行混合，，从而更有效地改进图像边缘的渐变效果。

####  快速近似抗锯齿(FXAA)

快速近似抗锯齿(Fast Approximate Anti-Aliasing，简称FXAA) ，是传统MSAA(多重采样抗锯齿)效果的一种高性能近似。它是一种单程像素着色器，和MLAA一样运行于目标游戏渲染管线的后期处理阶段，但不像后者那样使用DirectCompute，而只是单纯的后期处理着色器，不依赖于任何GPU计算API。正因为如此，FXAA技术对显卡没有特殊要求，完全兼容NVIDIA、AMD的不同显卡(MLAA仅支持A卡)和DirectX 9.0、DirectX 10、DirectX 11。

相比于MSAA，FXAA的目标是速度更快、显存占用更低，还有着不会造成镜面模糊和亚像素模糊(表面渲染不足一个像素时的闪烁现象)的优势，而代价就是精度和质量上的损失。

#### 时间性抗锯齿[(TXAA)](https://bartwronski.com/2014/03/15/temporal-supersampling-and-antialiasing/)

时间性抗锯齿（Temporal Anti-Aliasing，简称TXAA），将 MSAA、时间滤波以及后期处理相结合，用于呈现更高的视觉保真度。与CG电影中所采用的技术类似，TXAA集MSAA的强大功能与复杂的解析滤镜于一身，可呈现出更加平滑的图像效果。此外，TXAA还能够对帧之间的整个场景进行抖动采样，以减少闪烁情形，闪烁情形在技术上又称作时间性锯齿。目前，TXAA有两种模式：TXAA 2X和TXAA4X。TXAA 2X可提供堪比8X MSAA的视觉保真度，然而所需性能却与2X MSAA相类似；TXAA 4X的图像保真度胜过8XMSAA，所需性能仅仅与4X MSAA相当。

#### 多帧采样抗锯齿（MFAA）

多帧采样抗锯齿（Multi-Frame Sampled Anti-Aliasing，MFAA）是 NVIDIA公司根据MSAA改进出的一种抗锯齿技术。目前仅搭载 Maxwell 架构GPU的显卡才能使用。可以将MFAA理解为MSAA的优化版，能够在得到几乎相同效果的同时提升性能上的表现。MFAA与MSAA最大的差别就在于在同样开启4倍效果的时候MSAA是真正的针对每个边缘像素周围的4个像素进行采样，MFAA则是仅仅只是采用交错的方式采样边缘某个像素周围的两个像素。



### 透明渲染与透明排序

#### 透明渲染

Screen-Door Transparency方法。基本思想是用棋盘格填充模式来绘制透明多边形，也就是说，以每隔一个像素绘制一点方式的来绘制一个多边形，这样会使在其后面的物体部分可见，通常情况下，屏幕上的像素比较紧凑，以至于棋盘格的这种绘制方式并不会露馅。screen-door transparency方法的优点就是简单，可以在任何时间任何顺序绘制透明物体，并不需要特殊的硬件支持（只要支持填充模式）。缺点是透明度效果仅在50%时最好，且屏幕的每个区域中只能绘制一个透明物体。

Alpha混合（Alpha Blending）方法。这个方法比较常见，其实就是按照Alpha混合向量的值来混合源像素和目标像素。当在屏幕上绘制某个物体时，与每个像素相关联的值有RGB颜色和Z缓冲深度值，以及另外一个成分alpha分量，这个alpha值也可以根据需要生成并存储，它描述的是给定像素的对象片段的不透明度的值。 alpha为1.0表示对象不透明，完全覆盖像素所在区域; 0.0表示像素完全透明。为了使对象透明，在现有场景的上方，以小于1的透明度进行绘制即可。每个像素将从渲染管线接收到一个RGBA结果，并将这个值和原始像素颜色相混合。

#### 透明排序

要将透明对象正确地渲染到场景中，通常需要对物体进行排序。下面分别介绍两种比较基本的透明排序方法（深度缓存和画家算法）和两种高级别的透明排序算法（加权平均值算法和深度剥离）。

##### Z-Buffer

Z-Buffer也称深度缓冲。在计算机图形学中，深度缓冲是在三维图形中处理图像深度坐标的过程，这个过程通常在硬件中完成，它也可以在软件中完成，它是可见性问题的一种常见解决方法。

Z-Buffering是在为物件进行着色时，执行“隐藏面消除”工作的一项技术，所以隐藏物件背后的部分就不会被显示出来。在3D环境中每个像素中会利用一组数据资料来定义像素在显示时的纵深度（即Z轴坐标值）。Z-Buffer所用的位数越高，则代表该显示卡所提供的物件纵深感也越精确。

Z-buffer的限制是每像素只存储一个对象。如果一些透明对象与同一个像素重叠，那么单独的Z-buffer就不能存储并且稍后再解析出所有可见对象的效果。这个问题是通过改变加速器架构来解决的，比如用A-buffer。A-buffer具有“深度像素（deep pixels）”，其可以在单个像素中存储一系列呈现在所有对象之后被解析为单个像素颜色的多个片段。但需注意，Z-buffer是市场的主流选择。

##### 画家算法（Painter's Algorithm）

画家算法（Painter's Algorithm）也称优先填充算法，油画家算法。效率虽然较低，但还是可以有效处理透明排序的问题。其基本思想是按照画家在绘制一幅画作时，首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分。画家算法首先将场景中的多边形根据深度进行排序，然后按照顺序进行描绘。这种方法通常会将不可见的部分覆盖，这样就可以解决可见性问题。

#### 排序算法

##### 加权平均值算法（Weighted Average）

使用简单的透明混合公式来实现无序透明渲染的算法，它通过扩展透明混合公式，来实现无序透明物件的渲染，从而得到一定程度上逼真的结果。

##### 深度剥离算法（Depth Peeling）

深度剥离是一种对深度值进行排序的技术。它的原理比较直观，标准的深度检测使场景中的Z值最小的点输出到屏幕上，就是离我们最近的顶点。但还有离我们第二近的顶点，第三近的顶点存在。要想显示它们，可以用多遍渲染的方法。第一遍渲染时，按照正常方式处理，这样就得到了离我们最近的表面中的每个顶点的z值。在第二遍渲染时，把现在每个顶点的深度值和刚才的那个深度值进行比较，凡是小于等于第一遍得到的z值，把它们剥离，后面的过程依次类推即可。

| ![](F:\Projects\Relevant\SIGHIVE\Blog\Pictures\20190506175906.png) |
| :----------------------------------------------------------: |
| 图5：每个深度剥离通道渲染特定的一层透明通道。左侧是第一个Pass，直接显示眼睛可见的层，中间显示了第二层，显示了每个像素处第二靠近透明表面的像素。右边的图是第三层，显示处第三靠近透明表面的像素 |



#### Gamma校正

为图像进行Gamma校正的目的是用来对人类视觉的特性进行补偿，从而根据人类对光线或者黑白的感知，最大化地利用表示黑白的数据位或带宽。

当我们计算出场景中所有像素的最终颜色以后，我们就必须把它们显示在监视器上。过去，大多数监视器是阴极射线管显示器（CRT）。这些监视器有一个物理特性就是两倍的输入电压产生的不是两倍的亮度。输入电压产生约为输入电压的2.2次幂的亮度，2.2就是CRT的Gamma系数。公式：设备输出亮度 = 电压的Gamma次幂

当Gamma 值为 1时，对应一个“理想”监视器，这个监视器具有从完美的白色通过灰色到黑色的连续线性渐变效果。然而，理想的显示设备是不存在的。电脑监视器是“非线性”的设备。gamma 值越高，非线性程度越大。NTSC 视频的标准 gamma 值为 2.2。对于电脑监视器，gamma 值一般在 1.5 到 2.0 之间。

| ![gamma_correction_gamma_curves](F:\Projects\Relevant\SIGHIVE\Blog\Pictures\gamma_correction_gamma_curves.png) |
| ------------------------------------------------------------ |
| 图4：灰色点线为Gamma为1的理想状态，红色实线代表监视器显示Gamma为2.2 |

Gamma校正(Gamma Correction)的思路是在最终的颜色输出上应用监视器Gamma的倒数。我们在颜色显示到监视器的时候把每个颜色输出都加上这个翻转的Gamma曲线，这样应用了监视器Gamma以后最终的颜色将会变为线性的。我们所得到的中间色调就会更亮，所以虽然监视器使它们变暗，但是我们又将其平衡回来了。

2.2通常是是大多数显示设备的大概平均gamma值。基于gamma2.2的颜色空间叫做sRGB颜色空间。每个监视器的gamma曲线都有所不同，但是gamma2.2在大多数监视器上表现都不错。

有两种方法在场景中应用Gamma校正：使用OpenGL内建的sRGB帧缓冲， 自己在像素着色器中进行gamma校正。

